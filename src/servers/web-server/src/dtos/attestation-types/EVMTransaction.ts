//////////////////////////////////////////////////////////////////////////////////////////
/////// THIS CODE IS AUTOGENERATED. DO NOT CHANGE!!!                             /////////
//////////////////////////////////////////////////////////////////////////////////////////
import { ApiProperty } from "@nestjs/swagger";
import { Validate, IsOptional, IsHexadecimal, IsBoolean, ValidationArguments, ValidatorConstraint, ValidatorConstraintInterface } from "class-validator";

export namespace EVMTransaction {
  ///////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////// CUSTOM VALIDATORS ////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////////////////////

  /**
   * Validator constraint if the given value is a number or 0x-prefixed hexadecimal string.
   */
  @ValidatorConstraint({ name: "unsigned-int", async: false })
  export class IsUnsignedIntLike implements ValidatorConstraintInterface {
    /**
     * Validates if the given value is a string of decimal unsigned number or 0x-prefixed hexadecimal string.
     * @param text
     * @param args
     * @returns
     */
    validate(text: any, args: ValidationArguments) {
      return typeof text === "string" && (/^0x[0-9a-fA-F]+$/i.test(text) || /^[0-9]+$/i.test(text));
    }

    /**
     * Returns the default error message template.
     * @param args
     * @returns
     */
    defaultMessage(args: ValidationArguments) {
      return "($property) value ($value) is not a decimal number in string or 0x-prefixed hexadecimal string";
    }
  }

  /**
   * Validator constraint if the given value is a number or 0x-prefixed hexadecimal string.
   */
  @ValidatorConstraint({ name: "signed-int", async: false })
  export class IsSignedIntLike implements ValidatorConstraintInterface {
    /**
     * Validates if the given value is a number or 0x-prefixed hexadecimal string.
     * @param text
     * @param args
     * @returns
     */
    validate(text: any, args: ValidationArguments) {
      return typeof text === "string" && (/^-?0x[0-9a-fA-F]+$/i.test(text) || /^-?[0-9]+$/i.test(text));
    }

    /**
     * Returns the default error message template.
     * @param args
     * @returns
     */
    defaultMessage(args: ValidationArguments) {
      return "($property) value ($value) is not a signed decimal integer in string or signed 0x-prefixed hexadecimal string";
    }
  }

  /**
   * Validator constraint if the given value is a 0x-prefixed hexadecimal string representing 32 bytes.
   */
  @ValidatorConstraint({ name: "hash-32", async: false })
  export class IsHash32 implements ValidatorConstraintInterface {
    /**
     * Validates if the given value is a 0x-prefixed hexadecimal string representing 32 bytes.
     * @param text
     * @param args
     * @returns
     */
    validate(text: any, args: ValidationArguments) {
      return typeof text === "string" && /^0x[0-9a-f]{64}$/i.test(text);
    }

    /**
     * Returns the default error message template.
     * @param args
     * @returns
     */
    defaultMessage(args: ValidationArguments) {
      return "($property) value ($value) is not 0x-prefixed hexadecimal string representing 32 bytes";
    }
  }

  /**
   * Validator constraint if the given value is an EVM address, hence 0x-prefixed hexadecimal string representing 20 bytes.
   */
  @ValidatorConstraint({ name: "evm-address", async: false })
  export class IsEVMAddress implements ValidatorConstraintInterface {
    /**
     * Validates if the given value is an EVM address, hence 0x-prefixed hexadecimal string representing 20 bytes.
     * @param text
     * @param args
     * @returns
     */
    validate(text: any, args: ValidationArguments) {
      return typeof text === "string" && /^0x[0-9a-f]{40}$/i.test(text);
    }

    /**
     * Returns the default error message template.
     * @param args
     * @returns
     */
    defaultMessage(args: ValidationArguments) {
      return "($property) value ($value) is not 0x-prefixed hexadecimal string representing 20 bytes (EVM address)";
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////// DTOs /////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////////////////////

  export class Request {
    constructor(params: Required<Request>) {
      Object.assign(this, params);
    }

    /**
     * Attestation type id as defined for each attestation type on [this repo](https://gitlab.com/flarenetwork/state-connector-protocol/)
     */
    @IsHexadecimal()
    @ApiProperty({
      description: `Attestation type id as defined for each attestation type on [this repo](https://gitlab.com/flarenetwork/state-connector-protocol/)`,
    })
    attestationType!: string;

    /**
     * Data source id as defined [here](/attestation-objects/enums.md).
     */
    @IsHexadecimal()
    @ApiProperty({ description: `Data source id as defined [here](/attestation-objects/enums.md).` })
    sourceId!: string;

    /**
     * `MessageIntegrityCode` that is derived from the expected response as defined [here](/attestation-objects/MIC.md#message-integrity-code).
     */
    @IsHexadecimal()
    @ApiProperty({
      description: `'MessageIntegrityCode' that is derived from the expected response as defined [here](/attestation-objects/MIC.md#message-integrity-code).`,
    })
    messageIntegrityCode!: string;

    /**
     * Data defining the request. Type (struct) and interpretation is determined by the `attestationType`.
     */
    @ApiProperty({ description: `Data defining the request. Type (struct) and interpretation is determined by the 'attestationType'.` })
    requestBody!: RequestBody;
  }
  export class Response {
    constructor(params: Required<Response>) {
      Object.assign(this, params);
    }

    /**
     * Extracted from the request.
     */
    @IsHexadecimal()
    @ApiProperty({ description: `Extracted from the request.` })
    attestationType!: string;

    /**
     * Extracted from the request.
     */
    @IsHexadecimal()
    @ApiProperty({ description: `Extracted from the request.` })
    sourceId!: string;

    /**
     * The id of the state connector round in which the request was considered. This is a security measure to prevent collision of attestation hashes.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({
      description: `The id of the state connector round in which the request was considered. This is a security measure to prevent collision of attestation hashes.`,
    })
    votingRound!: string;

    /**
     * The lowest timestamp used to generate the response.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({ description: `The lowest timestamp used to generate the response.` })
    lowestUsedTimestamp!: string;

    /**
     * Extracted from the request.
     */
    @ApiProperty({ description: `Extracted from the request.` })
    requestBody!: RequestBody;

    /**
     * Data defining the response. The verification rules for the construction of the response body and the type are defined per specific `attestationType`.
     */
    @ApiProperty({
      description: `Data defining the response. The verification rules for the construction of the response body and the type are defined per specific 'attestationType'.`,
    })
    responseBody!: ResponseBody;
  }
  export class Proof {
    constructor(params: Required<Proof>) {
      Object.assign(this, params);
    }

    /**
     * Merkle proof corresponding to the attestation response.
     */
    @ApiProperty({ description: `Merkle proof corresponding to the attestation response.` })
    merkleProof!: string[];

    /**
     * Attestation response.
     */
    @ApiProperty({ description: `Attestation response.` })
    data!: Response;
  }
  export class RequestBody {
    constructor(params: Required<RequestBody>) {
      Object.assign(this, params);
    }

    /**
     * Hash of the transaction(transactionHash).
     */
    @IsHexadecimal()
    @ApiProperty({ description: `Hash of the transaction(transactionHash).` })
    transactionHash!: string;

    /**
     * Height at which a block is considered confirmed by the requestor.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({ description: `Height at which a block is considered confirmed by the requestor.` })
    requiredConfirmations!: string;

    /**
     * If true, "input" field is included in the response.
     */
    @IsBoolean()
    @ApiProperty({ description: `If true, "input" field is included in the response.` })
    provideInput!: boolean;

    /**
     * If true, events indicated by `logIndices` are included in the response. Otherwise, no events are included in the response.
     */
    @IsBoolean()
    @ApiProperty({ description: `If true, events indicated by 'logIndices' are included in the response. Otherwise, no events are included in the response.` })
    listEvents!: boolean;

    /**
     * Indices of the events, sorted by the requestor, to be relayed. The array should contain at most 50 indices. If empty, it indicates all events in order capped by 50.
     */
    @ApiProperty({
      description: `Indices of the events, sorted by the requestor, to be relayed. The array should contain at most 50 indices. If empty, it indicates all events in order capped by 50.`,
    })
    logIndices!: string[];
  }

  export class ResponseBody {
    constructor(params: Required<ResponseBody>) {
      Object.assign(this, params);
    }

    /**
     * Number of the block in which the transaction is included.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({ description: `Number of the block in which the transaction is included.` })
    blockNumber!: string;

    /**
     * Timestamp of the block in which the transaction is included.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({ description: `Timestamp of the block in which the transaction is included.` })
    timestamp!: string;

    /**
     * The address (from) that signed the transaction.
     */
    @Validate(IsEVMAddress)
    @ApiProperty({ description: `The address (from) that signed the transaction.` })
    sourceAddress!: string;

    /**
     * The address (to) of the receiver of the initial transaction.
     */
    @Validate(IsEVMAddress)
    @ApiProperty({ description: `The address (to) of the receiver of the initial transaction.` })
    receivingAddress!: string;

    /**
     * The value transferred by the initial transaction in wei.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({ description: `The value transferred by the initial transaction in wei.` })
    value!: string;

    /**
     * If `provideInput`, this is the data send along with the initial transaction. Otherwise it is the default value `0x`.
     */
    @IsHexadecimal()
    @ApiProperty({ description: `If 'provideInput', this is the data send along with the initial transaction. Otherwise it is the default value '0x'.` })
    input!: string;

    /**
     * Status of the transaction 1 - success, 0 - failure.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({ description: `Status of the transaction 1 - success, 0 - failure.` })
    status!: string;

    /**
     * If `listEvents` is true, an array of the requested events. Sorted by the logIndex in the same order as `logIndices`. Otherwise, an empty array.
     */
    @ApiProperty({
      description: `If 'listEvents' is true, an array of the requested events. Sorted by the logIndex in the same order as 'logIndices'. Otherwise, an empty array.`,
    })
    events!: Event[];
  }
  export class Event {
    constructor(params: Required<Event>) {
      Object.assign(this, params);
    }

    /**
     * Consecutive number of the event in block.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({ description: `Consecutive number of the event in block.` })
    logIndex!: string;

    /**
     * Address of the contract that emitted the event.
     */
    @Validate(IsEVMAddress)
    @ApiProperty({ description: `Address of the contract that emitted the event.` })
    emitterAddress!: string;

    /**
     * An array of up to 4 32-byte strings of indexed log arguments. The first string is the signature of the event.
     */
    @ApiProperty({ description: `An array of up to 4 32-byte strings of indexed log arguments. The first string is the signature of the event.` })
    topics!: string[];

    /**
     * Concatenated 32-byte strings of non-indexed log arguments. At least 32 bytes long.
     */
    @IsHexadecimal()
    @ApiProperty({ description: `Concatenated 32-byte strings of non-indexed log arguments. At least 32 bytes long.` })
    data!: string;

    /**
     * It is true if log was removed due to a chain reorganization and false if it is a valid log.
     */
    @IsBoolean()
    @ApiProperty({ description: `It is true if log was removed due to a chain reorganization and false if it is a valid log.` })
    removed!: boolean;
  }
}
